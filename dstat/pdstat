#!/bin/bash

#########################################################################
##
## TITLE:         pdstat
## AUTHOR:        Rodolfo Mói de Oliveira
## DESCRIPTION:   pdstat is a Gnuplot script for plotting graphs from dstat
##                metric data.
## DATE:          16. Mar. 2023
## LICENSE:       MIT
##
#########################################################################

declare TRACE
[[ "${TRACE}" == 1 ]] && set -o xtrace
set -o errexit
set -o pipefail
set -o noclobber

COLOR_BG="#ffffff"
COLOR_FG="#000000"
FONT="Merriweather"
FONT_SCALE=1
HEIGHT=350
LINE_WIDTH=1.5
PREVIEW_PLOT=true
TITLE="dstat"
VERBOSE=false
WIDTH=1400
RANGE_X='0:100'
HAS_MOD_X=false
MOD_X=1

PLOT_XDATA='set xdata time'
PLOT_TIMEFMT='set timefmt "%d/%m-%H:%M:%S"'
PLOT_FORMAT_X='set format x "%H:%M:%S"'

declare -A VALID_DSTAT_FLAGS=(
  ["time"]="time"
  ["cpu"]="usr sys idl wai stl"
  ["disk"]="read writ"
  ["page"]="in out"
  ["int"]="138 139 140"
  ["load"]="1m 5m 15m used"
  ["mem"]="free buff cach"
  ["net"]="recv send"
  ["proc"]="run blk new"
  ["io"]="read writ"
  ["swap"]="used free"
  ["sys"]="int csw"
  ["aio"]="aio"
  ["fs"]="files inodes"
  ["ipc"]="msg sem shm"
  ["lock"]="pos lck rea wri"
  ["raw"]="raw"
  ["socket"]="tot tcp udp raw frg"
  ["tcp"]="lis act syn tim clo"
  ["udp"]="lis act"
  ["unix"]="dgm str lis act"
  ["vm"]="majpf minpf alloc free"
  ["vm-adv"]="steal scanK scanD pgoru astll"
  ["zones"]="d32F d32H normF normH"
)

declare -A VALID_DSTAT_HEADERS=(
  ["system_time"]=true
  ["total-cpu-usage_usr"]=true
  ["total-cpu-usage_sys"]=true
  ["total-cpu-usage_idl"]=true
  ["total-cpu-usage_wai"]=true
  ["total-cpu-usage_stl"]=true
  ["dsk_total_read"]=true
  ["dsk_total_writ"]=true
  ["paging_in"]=true
  ["paging_out"]=true
  ["interrupts_138"]=true
  ["interrupts_139"]=true
  ["interrupts_140"]=true
  ["load-avg_1m"]=true
  ["load-avg_5m"]=true
  ["load-avg_15m"]=true
  ["memory-usage_used"]=true
  ["memory-usage_free"]=true
  ["memory-usage_buff"]=true
  ["memory-usage_cach"]=true
  ["net_total_recv"]=true
  ["net_total_send"]=true
  ["procs_run"]=true
  ["procs_blk"]=true
  ["procs_new"]=true
  ["io_total_read"]=true
  ["io_total_writ"]=true
  ["swap_used"]=true
  ["swap_free"]=true
  ["system_int"]=true
  ["system_csw"]=true
  ["async_aio"]=true
  ["filesystem_files"]=true
  ["filesystem_inodes"]=true
  ["sysv-ipc_msg"]=true
  ["sysv-ipc_sem"]=true
  ["sysv-ipc_shm"]=true
  ["file-locks_pos"]=true
  ["file-locks_lck"]=true
  ["file-locks_rea"]=true
  ["file-locks_wri"]=true
  ["raw_raw"]=true
  ["sockets_tot"]=true
  ["sockets_tcp"]=true
  ["sockets_udp"]=true
  ["sockets_raw"]=true
  ["sockets_frg"]=true
  ["tcp-sockets_lis"]=true
  ["tcp-sockets_act"]=true
  ["tcp-sockets_syn"]=true
  ["tcp-sockets_tim"]=true
  ["tcp-sockets_clo"]=true
  ["udp_lis"]=true
  ["udp_act"]=true
  ["unix-sockets_dgm"]=true
  ["unix-sockets_str"]=true
  ["unix-sockets_lis"]=true
  ["unix-sockets_act"]=true
  ["virtual-memory_majpf"]=true
  ["virtual-memory_minpf"]=true
  ["virtual-memory_alloc"]=true
  ["virtual-memory_free"]=true
  ["advanced-virtual-memory_steal"]=true
  ["advanced-virtual-memory_scanK"]=true
  ["advanced-virtual-memory_scanD"]=true
  ["advanced-virtual-memory_pgoru"]=true
  ["advanced-virtual-memory_astll"]=true
  ["zones-memory_d32F"]=true
  ["zones-memory_d32H"]=true
  ["zones-memory_normF"]=true
  ["zones-memory_normH"]=true
)

clean_tempdir() {
  rm -rf "${TMP_DIR}"
}

trap clean_tempdir EXIT

mktempdir() {
  if ! TMP_DIR=$(mktemp -d -t gnuplot-dstat-XXXXXXXXXX); then
    printf 1>&2 "Couldn't create %s\n" "${TMP_DIR}"
    exit 1
  fi
  DSTAT_FILE="${TMP_DIR}/input.dstat"
  DSTAT_WITH_DEFAULT_TIME="${TMP_DIR}/default_time.dstat"
  DSTAT_TIME_DATAPOINTS="${TMP_DIR}/time_datapoints.dstat"

  CSV_PARSED="${TMP_DIR}/parsed.csv"
  CSV_MOD="${TMP_DIR}/mod.csv"
  CSV_NUMFMT_CLEAN="${TMP_DIR}/numfmt_clean.csv"
  CSV_NUMFMT="${TMP_DIR}/numfmt.csv"
}

usage_short() {
  local help_text
  help_text=$(
    cat <<"EOF"
pdstat is a Gnuplot script for plotting graphs from dstat metric data.

Usage: pdstat [OPTIONS] <FILE>

Arguments:
  <FILE>       A FILE with dstat metric data

Options:
      --color-bg <COLOR>          Set background color [default: #ffffff]
      --color-fg <COLOR>          Set foreground color [default: #000000]
  -f, --font <FONT>               Multiplot font [default: Merriweather]
  -s, --font-scale <FONT-SCALE>   Multiplot font scale [default: 1]
  -g, --height <HEIGHT>           Multiplot height for each graph [default: 350]
  -l, --line-width <LINE-WIDTH>   Multiplot metric line width [default: 1]
  -o, --output <OUTPUT>           Output multiplot file [default: <FILE>.png]
  -p, --preview <BOOL>            Whether or not should open the multiplot after generation [default: true] [possible values: true, false]
  -t, --title <TITLE>             Multiplot title [default: dstat]
      --x-mod <MOD>               Select/filter data to plot by `datapoint line number mod <MOD> == 0` in the x-axis [default: 1]
  -x, --x-range <START>:<END>     Select/filter the range of data to plot in the x-axis [default: '0:100']
  -v, --verbose <BOOL>            Whether or not to be verbose [default: false] [possible values: true, false]
  -w, --width <WIDTH>             Multiplot width [default: 1400]
  -h, --help                      Print help information (use `--help` for more detail)
EOF
  )

  printf 1>&2 "%s\n" "${help_text}"
}

usage_long() {
  local help_text
  help_text=$(
    cat <<"EOF"
pdstat is a Gnuplot script for plotting graphs from dstat metric data.

Usage:
  pdstat [OPTIONS] <FILE>

Arguments:
  <FILE>
          A FILE with dstat metric data

Options:
      --color-bg <COLOR>
          Set background color [default: #ffffff]

      --color-fg <COLOR>
          Set foreground color [default: #000000]

  -f, --font <FONT>
          Multiplot font [default: Merriweather]

  -s, --font-scale <FONT-SCALE>
          Multiplot font scale [default: 1]

  -g, --height <HEIGHT>
          Multiplot height for each graph [default: 350]

  -l, --line-width <LINE-WIDTH>
          Multiplot metric line width [default: 1]

  -o, --output <OUTPUT>
          Output multiplot file [default: <FILE>.png]

  -p, --preview <BOOL>
          Whether or not should open the multiplot after generation [default: true] [possible values: true, false]

  -t, --title <TITLE>
          Multiplot title [default: dstat]

      --x-mod <MOD>
          Select/filter data to plot by `data point line number mod <MOD> == 0` in the x-axis [default: 1]

  -x, --x-range <START>:<END>
          Select/filter the range of data to plot in the x-axis [default: '0:100']

  -v, --verbose <BOOL>
          Whether or not to be verbose [default: false] [possible values: true, false]

  -w, --width <WIDTH>
          Multiplot width [default: 1400]

  -h, --help
          Print help information (use `--help` for more detail)

Examples:

  Get some data
    dstat --time --cpu --disk --socket 1 60 | tee file.dstat

  Plot from data
    pdstat file.dstat

  Change plot styles
    pdstat \
      --color-bg "#000000" \
      --color-fg "#ffffff" \
      --font 'Roboto' \
      --font-scale 0.9 \
      --line-width 3 \
      --width 1300 \
      --height 300 \
      file.dstat

  Slice your data
    pdstat --x-range 50:100 file.dstat

  Decrease the granularity of data points
    pdstat --x-mod 2 file.dstat

Author:
  Rodolfo Mói de Oliveira (https://github.com/rodmoioliveira)

Bug Report:
  If you wish to file a bug report, please go to
  https://github.com/rodmoioliveira/Gnuplotting-Stuff/issues
EOF
  )

  printf 1>&2 "%s\n" "${help_text}"
}

error_wrong_input() {
  local count="${1}"
  local invalid_headers="${2}"
  printf 1>&2 "Input <FILE>:%s has %s invalid headers ...\n\n" "${FILE}" "${count}"
  printf 1>&2 "    %s\n" "${invalid_headers}"
  printf 1>&2 "\n"
  printf 1>&2 "The valid flags accepted to generate data from the dstat command are:\n\n"
  printf 1>&2 "%-10s    PDSTAT_HEADER\n" "DSTAT_FLAG"
  for flag in "${!VALID_DSTAT_FLAGS[@]}"; do
    printf 1>&2 -- "--%-10s  %s\n" "${flag}" "${VALID_DSTAT_FLAGS[${flag}]}"
  done
  printf 1>&2 "\n"
  printf 1>&2 "pdstat doesn't accept data generated with dstat using other flags.\n"
  printf 1>&2 "\nFor more information try '--help'\n"
  exit 1
}

error_no_input() {
  printf 1>&2 "No <FILE> input ...\n"
  printf 1>&2 "\nFor more information try '--help'\n"
  exit 1
}

error_x_range() {
  local error="${1}"
  printf 1>&2 "%s ...\n" "${error}"
  printf 1>&2 "\nFor more information try '--help'\n"
  exit 1
}

error_x_mod() {
  local error="${1}"
  printf 1>&2 "%s ...\n" "${error}"
  printf 1>&2 "\nFor more information try '--help'\n"
  exit 1
}

error_preview() {
  printf 1>&2 "the flag --preview <BOOL> must be 'true' or 'false' ...\n"
  printf 1>&2 "\nFor more information try '--help'\n"
  exit 1
}

error_verbose() {
  printf 1>&2 "the flag --verbose <BOOL> must be 'true' or 'false' ...\n"
  printf 1>&2 "\nFor more information try '--help'\n"
  exit 1
}

deps_validate() {
  summary=()
  is_valid=true

  deps=("bc" "gawk" "getopt" "gnuplot" "rg" "sd" "numfmt")
  for dep in "${deps[@]}"; do
    if ! command -v "${dep}" &>/dev/null; then
      summary+=("[deps] ${dep} ... Missing!")
      is_valid=false
    else
      summary+=("[deps] ${dep} ... OK")
    fi
  done

  if [[ "${is_valid}" == false ]]; then
    printf 1>&2 "You have missing dependencies.\n"
    printf 1>&2 "You must install the missing dependencies for pdstat work correctly.\n\n"
    printf 1>&2 "%s\n" "${summary[@]}"
    exit 1
  fi

  if [[ "${VERBOSE}" == true ]]; then
    printf 1>&2 "%s\n" "${summary[@]}"
  fi
}

args_parse() {
  local args
  if ! args=$(
    getopt -a \
      -n dstat \
      -o ho:v:f:g:l:p:s:t:w:x: \
      --long help,preview:,verbose:,output:,width:,height:,font:,title:,font-scale:,line-width:,color-fg:,color-bg:,x-range:,x-mod: \
      -- "$@"
  ); then
    printf 1>&2 "\nFor more information try '--help'\n"
    exit 1
  fi
  eval set -- "${args}"

  while [[ $# -gt 0 ]]; do
    case "$1" in
    -o | --output)
      shift
      OUTPUT="$1"
      ;;
    -w | --width)
      shift
      WIDTH="$1"
      ;;
    -g | --height)
      shift
      HEIGHT="$1"
      ;;
    -f | --font)
      shift
      FONT="$1"
      ;;
    -s | --font-scale)
      shift
      FONT_SCALE="$1"
      ;;
    -l | --line-width)
      shift
      LINE_WIDTH="$1"
      ;;
    -t | --title)
      shift
      TITLE="$1"
      ;;
    --color-fg)
      shift
      COLOR_FG="$1"
      ;;
    --color-bg)
      shift
      COLOR_BG="$1"
      ;;
    -x | --x-range)
      shift
      RANGE_X="$1"
      ;;
    --x-mod)
      shift
      MOD_X="$1"
      ;;
    -p | --preview)
      shift
      PREVIEW_PLOT="$1"
      ;;
    -v | --verbose)
      shift
      VERBOSE="$1"
      ;;
    -h)
      usage_short
      exit 0
      ;;
    --help)
      usage_long
      exit 0
      ;;
    --)
      shift
      break
      ;;
    *) usage_long ;;
    esac
    shift
  done

  FILE="${1}"
  if [[ -z "${FILE}" ]]; then
    error_no_input
  fi
}

arg_x_range() {
  if ! range=$(echo "${RANGE_X}" | rg '^\d{1,3}:\d{1,3}$'); then
    error_x_range "the value '<START>:<END>' for the flag --x-range must match the regex '^\d{1,3}:\d{1,3}$'"
  fi

  range_x_start=$(echo "${range}" | awk -F ':' '{print $1}')
  range_x_end=$(echo "${range}" | awk -F ':' '{print $2}')

  if [[ $(echo "${range_x_start} >= ${range_x_end}" | bc) == 1 ]]; then
    error_x_range "the values '<START>:<END>' for the flag --x-range must respect that '<START>' is smaller than '<END>'"
  fi

  if [[ $(echo "${range_x_start} < 0" | bc) == 1 ]]; then
    error_x_range "the values '<START>:<END>' for the flag --x-range must respect that '<START>' is equal or greater than 0"
  fi

  if [[ $(echo "${range_x_end} > 100" | bc) == 1 ]]; then
    error_x_range "the values '<START>:<END>' for the flag --x-range must respect that '<END>' is equal or smaller than 100"
  fi

  RANGE_X_START="${range_x_start}"
  RANGE_X_END="${range_x_end}"
}

arg_x_mod() {
  if [[ "${MOD_X}" == 0 ]]; then
    error_x_mod "the value '<MOD>' for the flag --x-mod can't be zero"
  fi

  if [[ "${MOD_X}" != 1 ]]; then
    HAS_MOD_X=true
  fi
}

arg_preview() {
  if ! [[ "${PREVIEW_PLOT}" == true || "${PREVIEW_PLOT}" == false ]]; then
    error_preview
  fi
}

arg_verbose() {
  if ! [[ "${VERBOSE}" == true || "${VERBOSE}" == false ]]; then
    error_verbose
  fi

  if [[ "${VERBOSE}" == true ]]; then
    GNUPLOT_ERRORS_SINK=/dev/stderr
  else
    GNUPLOT_ERRORS_SINK=/dev/null
  fi
}

arg_output() {
  if [[ -z "${OUTPUT}" ]]; then
    OUTPUT_FILE="$(echo "${FILE}" | awk -F'/' '{print $NF}' | awk -F'.' '{print $1}').png"
  else
    dir="$(dirname "${OUTPUT}")"
    if [[ "${dir}" != "." && ! -d "${dir}" ]]; then
      if ! mkdir -p "${dir}"; then
        printf 1>&2 "Couldn't create directory %s for output file ...\n" "${dir}"
        exit 1
      fi
    fi

    if [[ -d "${OUTPUT}" ]]; then
      printf 1>&2 "Couldn't create file %s for output ...\n" "${OUTPUT}"
      printf 1>&2 "%s is a directory\n" "${OUTPUT}"
      exit 1
    fi

    OUTPUT_FILE="${OUTPUT}"
  fi
}

args_validate() {
  arg_preview
  arg_verbose
  arg_output
  arg_x_range
  arg_x_mod
}

calc_font_size() {
  echo "${1} * ${FONT_SCALE}" | bc
}

dstat_to_csv() {
  if [[ "${VERBOSE}" == true ]]; then
    printf 1>&2 "[Processing] %s ... " "${FILE}"
  fi

  array_counter=0
  local -a headers
  local -a headers_stats
  local -a headers_parsed
  local -a headers_parsed_new_line

  cat "${FILE}" >"${DSTAT_FILE}"
  if ! searched_lines=$(cat "${DSTAT_FILE}" | rg -F "time" --line-number); then
    PLOT_XDATA=''
    PLOT_TIMEFMT=''
    PLOT_FORMAT_X='set format x "%g(t)"'

    time_data_length=$(cat "${DSTAT_FILE}" | wc -l)
    time_data_length=$((time_data_length - 2))

    echo "----system----" >"${DSTAT_TIME_DATAPOINTS}"
    echo "     time     " >>"${DSTAT_TIME_DATAPOINTS}"
    for i in $(seq 1 "${time_data_length}"); do
      echo "${i}" >>"${DSTAT_TIME_DATAPOINTS}"
    done

    paste -d '|' "${DSTAT_TIME_DATAPOINTS}" "${DSTAT_FILE}" >"${DSTAT_WITH_DEFAULT_TIME}"
    mv "${DSTAT_WITH_DEFAULT_TIME}" "${DSTAT_FILE}"
  fi

  while IFS= read -r q; do headers+=("${q}"); done < <(
    cat "${DSTAT_FILE}" |
      sd -- 'async' '--async--' |
      sd -- '- ' '-|' |
      sd -- '-{2,}' '' |
      sd -s -- '-|' '|' |
      sd -s -- '|-' '|' |
      sd '(\w)-$' '$1' |
      awk 'NR==1{print}' |
      sd '\|' '\n'
  )
  while IFS= read -r q; do headers_stats+=("${q}"); done < <(
    cat "${DSTAT_FILE}" |
      sd -- '- ' '-|' |
      sd -- '-{2,}' '' |
      sd -s -- '-|' '|' |
      sd -s -- '|-' '|' |
      awk 'NR==2{print}' |
      sd '\|' '\n' |
      sd '^ {1,1000}' '' |
      sd ' {2,1000}' ' ' |
      sd ' {0,1000}\n' '\n' |
      sd '#' ''
  )

  for hs in "${headers_stats[@]}"; do
    local -a stats
    while IFS= read -r q; do stats+=("${q}"); done < <(echo "${hs}" | sd ' ' '\n')
    for s in "${stats[@]}"; do headers_parsed+=("${headers[${array_counter}]}/${s}"); done
    stats=()
    array_counter=$((array_counter + 1))
  done

  local -a invalid_headers=()
  for h in ${headers_parsed[*]}; do
    ph=$(echo "${h}" | sd -s '/' '_')
    if [[ "${VALID_DSTAT_HEADERS[${ph}]}" != "true" ]]; then
      invalid_headers+=("${h}")
    fi
  done

  invalid_headers_count=$(wc -w <<<"${invalid_headers[@]}")
  if [[ $(echo "${invalid_headers_count} > 0" | bc) == 1 ]]; then
    error_wrong_input "${invalid_headers_count}" "${invalid_headers[*]}"
  fi

  headers_parsed_new_line=$(echo "${headers_parsed[@]}" | sd ' ' '\n')
  sd_cmd=""
  numfmt_cmd=""
  multiplot_layout_lines=0

  # Parsing phase
  echo "${headers_parsed[@]}" | sd ' ' ',' >|"${CSV_PARSED}"
  parsed_values=$(
    awk 'NR > 2 { print }' "${DSTAT_FILE}" |
      sd '(\d{2})-(\d{2}) ((\d{2}:){2}\d{2})' '${1}/${2}-${3}' |
      sd -s '|' ' ' |
      sd ' {1,1000}' ' ' |
      sd '^ ' '' |
      sd ' ' ',' |
      sd ',$' ''
  )

  if [[ "${HAS_MOD_X}" == true ]]; then
    mod_values=$(echo "${parsed_values}" | rg . --line-number)
    echo "${mod_values}" >"${CSV_MOD}"

    mod_regex_values=$(
      echo "${mod_values}" |
        rg . --line-number --color never |
        awk -F ':' '{print $1}' |
        sd '(.+)' 'scale=0; $1 % '"${MOD_X}"'' |
        bc -l |
        rg --line-number "^0$" |
        awk -F ':' '{print $1}'
    )

    mod_regex_values_count=$(echo "${mod_regex_values}" | wc -l)
    if [[ $(echo "${mod_regex_values_count} <= 1" | bc) == 1 ]]; then
      error_x_mod "the value '<MOD>' for the flag --x-mod is too high. No data points will be plotted"
    fi

    mod_regex=$(
      echo "${mod_regex_values}" |
        sd '\n' '$1|' |
        sd '\|$' '' |
        sd '(.+)' '^($1):'
    )

    eval "cat ${CSV_MOD} | rg '${mod_regex}' | sd '^\d{1,}:' ''" >>"${CSV_PARSED}"
  else
    echo "${parsed_values}" >>"${CSV_PARSED}"
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "system/time" --line-number); then
    time_column=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    sd_cmd+=' | sd "system/time" "time"'
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "total-cpu-usage/" --line-number); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_total_cpu_usage=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "total-cpu-usage/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "procs/" --line-number); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_procs=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "procs/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "memory-usage/" --line-number); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_memory_usage=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "memory-usage/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "paging/" --line-number); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_paging=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "paging/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "interrupts/" --line-number); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_interrupts=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "interrupts/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "load-avg/" --line-number); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_load_avg=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "load-avg/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "async/" --line-number); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_async_io=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "async/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "sysv-ipc/" --line-number); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_sysv_ipc=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "sysv-ipc/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "file-locks/" --line-number); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_file_locks=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "file-locks/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "raw/" --line-number); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_raw=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "raw/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "tcp-sockets/" --line-number); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_tcp=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "tcp-sockets/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "unix-sockets/" --line-number); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_unix_sockets=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "unix-sockets/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "sockets/" --line-number | rg -F "tcp-sockets/" -v | rg -F "unix-sockets/" -v); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_sockets=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "sockets/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "udp/" --line-number); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_udp=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "udp/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "zones-memory/" --line-number); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_zone_memory=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "zones-memory/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "dsk/total" --line-number); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_disk_total=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "dsk/total/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "net/total" --line-number); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_net_total=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "net/total/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "swap/" --line-number); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_swap=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "swap/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "filesystem/" --line-number); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_filesystem=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "filesystem/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "advanced-virtual-memory/" --line-number); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_virtual_memory_advanced=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "advanced-virtual-memory/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "virtual-memory/" --line-number | rg -F "advanced-virtual-memory/" -v); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_virtual_memory=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "virtual-memory/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg -F "io/total/" --line-number); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_io_total=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "io/total/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  if searched_lines=$(echo "${headers_parsed_new_line}" | rg '(system/int|system/csw)' --line-number); then
    line_numbers=$(echo "${searched_lines}" | awk -F':' '{print $1}')
    numfmt_cmd+=$(
      echo "${line_numbers}" |
        awk -F':' '{print $1}' |
        awk 'NR==1; END{print}' |
        sd -- '\n' '-' |
        sd -- '-$' '' |
        sd '(.+)' ' | numfmt --header --field $1 --from=si --delimiter=","'
    )
    plot_system_int_csw=$(
      echo "${line_numbers}" |
        sd '(.+)' '"" using 1:$1 with lines linestyle 1,' |
        sd '"' "'" |
        rg linestyle --line-number |
        sd '(\d{1,10}):(.+)(\d{1,10})(,)' '$2$1$4' |
        sd '\n' ' ' |
        sd ', $' '' |
        sd '(.+)' 'plot $1' |
        sd "plot ''" "plot \"${CSV_NUMFMT}\"" |
        sd "using 1" "using ${time_column}"
    )
    sd_cmd+=' | sd "system/" ""'
    multiplot_layout_lines=$((multiplot_layout_lines + 1))
  fi

  # numfmt clean up phase
  cat "${CSV_PARSED}" |
    sd '(\d)k' '${1}K' |
    sd '(\d)B' '${1}' >"${CSV_NUMFMT_CLEAN}"

  # Final phase
  eval "cat ${CSV_NUMFMT_CLEAN} ${numfmt_cmd} ${sd_cmd}" >"${CSV_NUMFMT}"

  # TODO add --debug flag
  # echo "headers =========================="
  # echo "${headers[@]}" | sd ' ' '\n'
  # echo "headers_stats =========================="
  # echo "${headers_stats[@]}" | sd ' ' '\n'
  # echo "headers_parsed =========================="
  # echo "${headers_parsed[@]}" | sd ' ' '\n'
  # echo "headers_parsed_new_line =========================="
  # echo "${headers_parsed_new_line[@]}"

  # echo "DSTAT_FILE =========================="
  # cat "${DSTAT_FILE}" | head -n2
  # echo "CSV_PARSED =========================="
  # cat "${CSV_PARSED}" | head -n1 | sd ',' '\n'
  # echo "CSV_NUMFMT_CLEAN =========================="
  # cat "${CSV_NUMFMT_CLEAN}" | head -n1 | sd ',' '\n'
  # echo "CSV_NUMFMT =========================="
  # cat "${CSV_NUMFMT}" | head -n1 | sd ',' '\n'

  if [[ "${VERBOSE}" == true ]]; then
    printf 1>&2 "Done!\n"
  fi
}

calc_x_range() {
  PLOT_RANGE_X_START="$(map_range "${RANGE_X_START}")"
  PLOT_RANGE_X_END="$(map_range "${RANGE_X_END}")"
}

map_range() {
  # https://stackoverflow.com/questions/12931115/algorithm-to-map-an-interval-to-a-smaller-interval
  # To map
  # [A, B] --> [a, b]
  # use this formula
  # (val - A)*(b-a)/(B-A) + a

  input="${1}"
  output_start=2
  output_end=$(wc -l "${CSV_NUMFMT}" | awk '{print $1}' | bc)
  input_start=0
  input_end=100

  output="(${input} - ${input_start}) * (${output_end} - ${output_start}) / (${input_end} - ${input_start}) + ${output_start}"
  line=$(echo "${output}" | bc)
  line_match=$(eval "rg . ${CSV_NUMFMT} --line-number | rg ^${line}: | sd '^\d{1,}:' ''")
  eval "echo ${line_match} | awk -F',' '{print \$${time_column}}'"
}

plot_draw() {
  height=$(echo "${multiplot_layout_lines} * ${HEIGHT}" | bc)

  gnuplot <<EOF 2>|"${GNUPLOT_ERRORS_SINK}"
set terminal pngcairo enhanced background rgb "${COLOR_BG}" size "${WIDTH}","${height}" font "${FONT},$(calc_font_size 16)"

set border linecolor rgb "${COLOR_FG}"
set grid linecolor rgb "${COLOR_FG}"
set key textcolor rgb "${COLOR_FG}"
set title textcolor rgb "${COLOR_FG}"
set xlabel textcolor rgb "${COLOR_FG}"
set xtics textcolor rgb "${COLOR_FG}"
set ylabel textcolor rgb "${COLOR_FG}"
set ytics textcolor rgb "${COLOR_FG}"

set lmargin at screen 0.08
set rmargin at screen 0.90

set output "${OUTPUT_FILE}"

set key right top outside autotitle columnhead font ",$(calc_font_size 11)" vertical
set multiplot layout ${multiplot_layout_lines}, 1 title "${TITLE}" textcolor rgb "${COLOR_FG}" font "${FONT}-Bold,$(calc_font_size 24)"
set datafile separator ','

$(echo "${PLOT_XDATA}")
$(echo "${PLOT_TIMEFMT}")
$(echo "${PLOT_FORMAT_X}")

set tics out font ",$(calc_font_size 11)"
set grid back xtics ytics

set style line 1 linecolor rgb '#44de2d26' linetype 1 linewidth ${LINE_WIDTH} pointtype 1 pointsize 1
set style line 2 linecolor rgb '#441f78b4' linetype 1 linewidth ${LINE_WIDTH} pointtype 1 pointsize 1
set style line 3 linecolor rgb '#4431a354' linetype 1 linewidth ${LINE_WIDTH} pointtype 1 pointsize 1
set style line 4 linecolor rgb '#44c51b8a' linetype 1 linewidth ${LINE_WIDTH} pointtype 1 pointsize 1
set style line 5 linecolor rgb '#44756bb1' linetype 1 linewidth ${LINE_WIDTH} pointtype 1 pointsize 1

set border back
set xrange ["${PLOT_RANGE_X_START}":"${PLOT_RANGE_X_END}"]

set title "Load Average" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_load_avg}")

set title "CPU (% Utilization)" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_total_cpu_usage}")

set title "Memory (Bytes)" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_memory_usage}")

set title "Virtual Memory (Bytes)" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_virtual_memory}")

set title "Virtual Memory Advanced (Bytes)" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_virtual_memory_advanced}")

set title "Zone Memory" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_zone_memory}")

set title "Network (Bytes)" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_net_total}")

set title "TCP" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_tcp}")

set title "UDP" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_udp}")

set title "Sockets" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_sockets}")

set title "Unix Sockets" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_unix_sockets}")

set title "IO Requests" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_io_total}")

set title "Async IO" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_async_io}")

set title "Disk" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_disk_total}")

set title "Filesystem" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_filesystem}")

set title "File Locks" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_file_locks}")

set title "Processes" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_procs}")

set title "Int Csw" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_system_int_csw}")

set title "Swap" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_swap}")

set title "Paging" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_paging}")

set title "Interrupts" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_interrupts}")

set title "IPC" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_sysv_ipc}")

set title "Raw" font "${FONT}-Bold,$(calc_font_size 18)"
$(echo "${plot_raw}")
exit
EOF
}

plot_preview() {
  if [[ "${PREVIEW_PLOT}" == true ]]; then
    uname_kernel="$(uname -s)"

    case "${uname_kernel}" in
    Linux*) xdg-open "${OUTPUT_FILE}" ;;
    Darwin*) open "${OUTPUT_FILE}" ;;
    CYGWIN* | MINGW* | *) ;;
    esac
  fi
}

main() {
  args_parse "$@"
  args_validate
  deps_validate
  mktempdir
  dstat_to_csv
  calc_x_range
  plot_draw
  plot_preview
}

main "$@"
